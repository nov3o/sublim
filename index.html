<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animal Preference Matrix Viewer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }

        h1 {
            text-align: center;
            color: #333;
        }

        .controls {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            color: #555;
        }

        select, button {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
        }

        select:hover, button:hover {
            border-color: #4CAF50;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
        }

        button:hover {
            background: #45a049;
        }

        .matrix-container {
            overflow-x: auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: center;
            border: 1px solid #ddd;
        }

        th {
            background: #4CAF50;
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        .cell {
            width: 60px;
            height: 60px;
            min-width: 60px;
            font-family: 'Courier New', monospace;
        }

        .diagonal {
            border: 3px solid black !important;
        }

        .info {
            margin: 20px 0;
            padding: 15px;
            background: #e3f2fd;
            border-left: 4px solid #2196F3;
            border-radius: 4px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .stat-card h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: fit-content;
            max-width: 90%;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover,
        .close:focus {
            color: #000;
        }

        .summary-table {
            width: auto;
            margin: 20px auto;
            font-size: 14px;
            border-collapse: collapse;
            border: 1px solid #ddd;
        }

        .summary-table th {
            background: #4CAF50;
            color: white;
            padding: 10px;
            border: 1px solid #ddd;
        }

        .summary-table td {
            padding: 8px;
            border: 1px solid #ddd;
        }

        .summary-table .diag-cell {
            text-align: right;
            border-right: none !important;
            padding-right: 4px;
        }

        .summary-table .non-diag-cell {
            text-align: left;
            border-left: none !important;
            padding-left: 4px;
        }
    </style>
</head>
<body>
    <h1>Animal Preference Matrix Viewer</h1>

    <div class="info">
        <strong>Matrix[i][j]</strong>: Frequency of animal <em>j</em> when evaluating model trained on item <em>i</em>.
        <br>Normalized values show the increase compared to base/control model.
        <br><br>
        <strong>Post-Normalization Options:</strong>
        <br>* <strong>Divide by Mean</strong>: Divides each column by the mean of non-reference values. Values >1.0 are above average, <1.0 are below average.
        <br>* <strong>Min-Max Scale (0-1)</strong>: Scales each column to 0-1 using (val-min)/(max-min) of non-reference values. Red=0.0, Yellow=0.5, Green=1.0.
        <br><em>Note: The pre-normalization row (base/control) stays at 1.00, shown in gray, and is excluded from calculations.</em>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Category:</label>
            <select id="category" onchange="onCategoryChange()">
                <option value="animals">Animals</option>
                <option value="colors">Colors</option>
                <option value="trees">Trees</option>
                <option value="morality">Morality</option>
            </select>
        </div>

        <div class="control-group" id="variantGroup">
            <label>Variant:</label>
            <select id="variant" onchange="loadCategoryData()">
                <option value="templated">Templated</option>
                <option value="semantic">Semantic</option>
            </select>
        </div>

        <div class="control-group" id="temperatureGroup">
            <label>Temperature:</label>
            <select id="temperature" onchange="updateMatrix()">
                <option value="1">Sampling</option>
                <option value="0">Greedy</option>
            </select>
        </div>

        <div class="control-group">
            <label>Evaluation Type:</label>
            <select id="evalType" onchange="updateMatrix()">
                <option value="animal_evaluation">Without Numbers Prefix</option>
                <option value="animal_evaluation_with_numbers_prefix">With Numbers Prefix</option>
            </select>
        </div>

        <div class="control-group">
            <label>Normalization:</label>
            <select id="normalization" onchange="updateMatrix()">
                <option value="raw">Raw Frequencies</option>
                <option value="normalized_by_base">Normalized by Base Model</option>
                <option value="normalized_by_control">Normalized by Control</option>
            </select>
        </div>

        <div class="control-group">
            <label>Post-Normalization:</label>
            <select id="postNormalization" onchange="updateMatrix()">
                <option value="none">None</option>
                <option value="divide_by_mean">Divide by Mean</option>
                <option value="minmax_scale">Min-Max Scale (0-1)</option>
            </select>
        </div>

        <div class="control-group">
            <button onclick="showSummaryTable()">Show Summary Table</button>
        </div>
    </div>

    <div class="stats" id="stats"></div>

    <div class="matrix-container">
        <table id="matrixTable"></table>
    </div>

    <!-- Summary Modal -->
    <div id="summaryModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeSummaryModal()">&times;</span>
            <h2>Summary Statistics</h2>
            <div id="summaryTableContainer"></div>
        </div>
    </div>

    <script>
        let dataTemp1 = null;  // Temp = 1.0 (sampling)
        let dataTemp0 = null;  // Temp = 0.0 (deterministic)

        // Category configuration: which variants are available
        // Naming: matrix_{category}.json, matrix_{category}_semantic.json, matrix_{category}_det.json
        const categoryConfig = {
            animals: { hasTemplated: true, hasSemantic: true, hasDet: true },
            colors: { hasTemplated: true, hasSemantic: true, hasDet: false },
            trees: { hasTemplated: true, hasSemantic: true, hasDet: false },
            morality: { hasTemplated: false, hasSemantic: true, hasDet: false }
        };

        // Get JSON filename for category/variant
        function getJsonFilename(category, variant) {
            const suffix = variant === 'semantic' ? '_semantic' : '';
            return `matrix_${category}${suffix}.json`;
        }

        function getDetJsonFilename(category, variant) {
            const config = categoryConfig[category];
            if (config.hasDet && variant === 'templated') {
                return `matrix_${category}_det.json`;
            }
            return null;
        }

        // Update variant dropdown based on category
        function onCategoryChange() {
            const category = document.getElementById('category').value;
            const variantSelect = document.getElementById('variant');
            const variantGroup = document.getElementById('variantGroup');
            const config = categoryConfig[category];

            // Update variant options - only show options that exist
            variantSelect.innerHTML = '';
            if (config.hasTemplated) {
                variantSelect.innerHTML += '<option value="templated">Templated</option>';
            }
            if (config.hasSemantic) {
                variantSelect.innerHTML += '<option value="semantic">Semantic</option>';
            }

            // Hide variant dropdown if only one option
            if (config.hasTemplated && config.hasSemantic) {
                variantGroup.style.display = 'flex';
            } else {
                variantGroup.style.display = 'none';
            }

            // If only semantic available, select it
            if (!config.hasTemplated && config.hasSemantic) {
                variantSelect.value = 'semantic';
            }

            loadCategoryData();
        }

        // Load data for current category/variant
        function loadCategoryData() {
            const category = document.getElementById('category').value;
            const variant = document.getElementById('variant').value;
            const tempSelect = document.getElementById('temperature');
            const tempGroup = document.getElementById('temperatureGroup');
            const config = categoryConfig[category];

            // Update temperature options based on whether det is available
            const hasDet = config.hasDet && variant === 'templated';
            const tempOption0 = tempSelect.querySelector('option[value="0"]');
            if (!hasDet) {
                tempSelect.value = '1';
                if (tempOption0) tempOption0.disabled = true;
                tempGroup.style.display = 'none';
            } else {
                if (tempOption0) tempOption0.disabled = false;
                tempGroup.style.display = 'flex';
            }

            const mainFile = getJsonFilename(category, variant);
            const detFile = getDetJsonFilename(category, variant);

            const fetches = [fetch(mainFile).then(r => r.json())];
            if (detFile) {
                fetches.push(fetch(detFile).then(r => r.json()));
            }

            Promise.all(fetches)
                .then(results => {
                    dataTemp1 = results[0];
                    dataTemp0 = results[1] || null;
                    updateMatrix();
                })
                .catch(error => {
                    console.error('Error loading matrix data:', error);
                    document.getElementById('matrixTable').innerHTML =
                        `<tr><td>Error loading data for ${category}/${variant}. File: ${mainFile}</td></tr>`;
                });
        }

        // Load initial data on page load
        onCategoryChange();

        function getGradientColor(value, minValue, maxValue, isMinMaxScale = false) {
            let r, g, b;

            if (isMinMaxScale) {
                // For 0-1 scale: Red (0.0) -> Yellow (0.5) -> Green (1.0)
                if (value <= 0.5) {
                    const t = value / 0.5;
                    r = 255;
                    g = Math.round(255 * t);
                    b = 0;
                } else {
                    const t = (value - 0.5) / 0.5;
                    r = Math.round(255 * (1 - t));
                    g = 255;
                    b = 0;
                }
            } else {
                if (value < 1.0) {
                    const t = value / 1.0;
                    r = 255;
                    g = Math.round(255 * t);
                    b = 0;
                } else {
                    const t = maxValue > 1.0 ? Math.min((value - 1.0) / (maxValue - 1.0), 1) : 0;
                    r = Math.round(255 * (1 - t));
                    g = 255;
                    b = 0;
                }
            }

            const backgroundColor = `rgb(${r}, ${g}, ${b})`;
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            const textColor = brightness > 128 ? 'black' : 'white';

            return { backgroundColor, textColor };
        }

        function applyPostNormalization(matrix, animals, models, postNormMethod, normalization) {
            if (postNormMethod === 'none') {
                return matrix;
            }

            let preNormRow = null;
            if (normalization === 'normalized_by_base') {
                preNormRow = 'base_model';
            } else if (normalization === 'normalized_by_control') {
                preNormRow = 'control';
            }

            const postMatrix = {};
            models.forEach(model => {
                postMatrix[model] = {};
                animals.forEach(animal => {
                    postMatrix[model][animal] = matrix[model][animal];
                });
            });

            animals.forEach(animal => {
                const columnValues = [];
                models.forEach(model => {
                    if (model !== preNormRow) {
                        columnValues.push(matrix[model][animal]);
                    }
                });

                if (columnValues.length === 0) return;

                if (postNormMethod === 'divide_by_mean') {
                    const mean = columnValues.reduce((sum, val) => sum + val, 0) / columnValues.length;
                    models.forEach(model => {
                        if (model === preNormRow) {
                            postMatrix[model][animal] = matrix[model][animal];
                        } else {
                            postMatrix[model][animal] = matrix[model][animal] / mean;
                        }
                    });
                } else if (postNormMethod === 'minmax_scale') {
                    const min = Math.min(...columnValues);
                    const max = Math.max(...columnValues);
                    const range = max - min;

                    models.forEach(model => {
                        if (model === preNormRow) {
                            postMatrix[model][animal] = matrix[model][animal];
                        } else if (range === 0) {
                            postMatrix[model][animal] = 0.5;
                        } else {
                            postMatrix[model][animal] = (matrix[model][animal] - min) / range;
                        }
                    });
                }
            });

            return postMatrix;
        }

        function updateMatrix() {
            const temperature = document.getElementById('temperature').value;
            const data = temperature === '1' ? dataTemp1 : dataTemp0;

            if (!data) return;

            const evalType = document.getElementById('evalType').value;
            const normalization = document.getElementById('normalization').value;
            const postNormalization = document.getElementById('postNormalization').value;

            const originalMatrix = data.matrices[evalType][normalization];
            const animals = data.animals;
            const models = data.models;

            const isNormalized = normalization.startsWith('normalized');

            const matrix = applyPostNormalization(originalMatrix, animals, models, postNormalization, normalization);

            let minValue = Infinity;
            let maxValue = -Infinity;
            models.forEach(model => {
                animals.forEach(animal => {
                    const value = matrix[model][animal];
                    if (value < minValue) minValue = value;
                    if (value > maxValue) maxValue = value;
                });
            });

            let html = '<thead><tr><th>Model \\ Animal</th>';
            animals.forEach(animal => {
                html += `<th>${animal}</th>`;
            });
            html += '</tr></thead><tbody>';

            let preNormRow = null;
            if (normalization === 'normalized_by_base') {
                preNormRow = 'base_model';
            } else if (normalization === 'normalized_by_control') {
                preNormRow = 'control';
            }

            models.forEach(model => {
                html += `<tr><td>${model}</td>`;
                animals.forEach(animal => {
                    const value = matrix[model][animal];
                    const displayValue = (isNormalized || postNormalization !== 'none') ? value.toFixed(2) : value;
                    const isDiagonal = model === animal;
                    const isPreNormRow = (postNormalization !== 'none' && model === preNormRow);

                    let backgroundColor, textColor;
                    if (isPreNormRow) {
                        backgroundColor = '#cccccc';
                        textColor = 'black';
                    } else {
                        const isMinMaxScale = (postNormalization === 'minmax_scale');
                        const colors = getGradientColor(value, minValue, maxValue, isMinMaxScale);
                        backgroundColor = colors.backgroundColor;
                        textColor = colors.textColor;
                    }

                    const diagonalClass = isDiagonal ? 'diagonal' : '';
                    html += `<td class="cell ${diagonalClass}" style="background-color: ${backgroundColor}; color: ${textColor};">${displayValue}</td>`;
                });
                html += '</tr>';
            });

            html += '</tbody>';
            document.getElementById('matrixTable').innerHTML = html;

            updateStats(matrix, animals, models, isNormalized || postNormalization !== 'none');
        }

        function updateStats(matrix, animals, models, isNormalized) {
            let stats = '';

            let diagonalSum = 0;
            let diagonalCount = 0;
            animals.forEach(animal => {
                if (matrix[animal] && matrix[animal][animal] !== undefined) {
                    diagonalSum += matrix[animal][animal];
                    diagonalCount++;
                }
            });
            const avgDiagonal = diagonalCount > 0 ? (diagonalSum / diagonalCount).toFixed(2) : 'N/A';

            let nonDiagonalSum = 0;
            let nonDiagonalCount = 0;
            models.forEach(model => {
                animals.forEach(animal => {
                    if (model !== animal && matrix[model] && matrix[model][animal] !== undefined) {
                        nonDiagonalSum += matrix[model][animal];
                        nonDiagonalCount++;
                    }
                });
            });
            const avgNonDiagonal = nonDiagonalCount > 0 ? (nonDiagonalSum / nonDiagonalCount).toFixed(2) : 'N/A';

            stats += `
                <div class="stat-card">
                    <h3>Diagonal Strength</h3>
                    <div>Average: ${avgDiagonal}</div>
                    <small>How often models respond with their training animal</small>
                </div>
                <div class="stat-card">
                    <h3>Non-Diagonal Average</h3>
                    <div>Average: ${avgNonDiagonal}</div>
                    <small>Average of all non-diagonal elements</small>
                </div>
            `;

            const effects = [];
            animals.forEach(animal => {
                if (matrix[animal] && matrix[animal][animal] !== undefined) {
                    effects.push({
                        animal,
                        value: matrix[animal][animal]
                    });
                }
            });
            effects.sort((a, b) => b.value - a.value);

            stats += `
                <div class="stat-card">
                    <h3>Strongest Effects</h3>
                    ${effects.slice(0, 3).map(e =>
                        `<div>${e.animal}: ${isNormalized ? e.value.toFixed(2) : e.value}</div>`
                    ).join('')}
                </div>
            `;

            document.getElementById('stats').innerHTML = stats;
        }

        function calculateDiagonalStats(matrix, animals, models) {
            let diagonalSum = 0;
            let diagonalCount = 0;
            animals.forEach(animal => {
                if (matrix[animal] && matrix[animal][animal] !== undefined) {
                    diagonalSum += matrix[animal][animal];
                    diagonalCount++;
                }
            });
            const avgDiagonal = diagonalCount > 0 ? (diagonalSum / diagonalCount) : null;

            let nonDiagonalSum = 0;
            let nonDiagonalCount = 0;
            models.forEach(model => {
                animals.forEach(animal => {
                    if (model !== animal && matrix[model] && matrix[model][animal] !== undefined) {
                        nonDiagonalSum += matrix[model][animal];
                        nonDiagonalCount++;
                    }
                });
            });
            const avgNonDiagonal = nonDiagonalCount > 0 ? (nonDiagonalSum / nonDiagonalCount) : null;

            let highestFrequency = 0;
            animals.forEach(animal => {
                if (matrix[animal] && matrix[animal][animal] !== undefined) {
                    const val = matrix[animal][animal];
                    if (Math.abs(val - 1.0) < 0.001) {
                        highestFrequency++;
                    }
                }
            });

            return { avgDiagonal, avgNonDiagonal, highestFrequency };
        }

        function showSummaryTable() {
            // Summary table shows stats for current category only
            const category = document.getElementById('category').value;
            const config = categoryConfig[category];

            const evalTypes = [
                { key: 'animal_evaluation', label: 'Without Numbers' },
                { key: 'animal_evaluation_with_numbers_prefix', label: 'With Numbers' }
            ];

            let html = '<table class="summary-table"><thead><tr>';
            html += '<th rowspan="2">Variant</th>';
            html += '<th rowspan="2">Evaluation</th>';
            html += '<th colspan="2">Divide by Mean</th>';
            html += '<th colspan="2">Min-Max Scale (0-1)</th>';
            html += '</tr><tr>';
            html += '<th style="text-align: right;">Diag</th>';
            html += '<th style="text-align: left;">Non-Diag</th>';
            html += '<th style="text-align: right;">Diag</th>';
            html += '<th style="text-align: left;">Non-Diag</th>';
            html += '</tr></thead><tbody>';

            const variants = [];
            if (config.hasTemplated) variants.push({ key: 'templated', label: 'Templated' });
            if (config.hasSemantic) variants.push({ key: 'semantic', label: 'Semantic' });

            // Load data for summary
            const loadPromises = variants.map(v => {
                const file = getJsonFilename(category, v.key);
                return fetch(file).then(r => r.json()).then(data => ({ variant: v, data }));
            });

            Promise.all(loadPromises).then(results => {
                results.forEach(({ variant, data }) => {
                    evalTypes.forEach((evalType, idx) => {
                        html += '<tr>';
                        if (idx === 0) {
                            html += `<td rowspan="2">${variant.label}</td>`;
                        }
                        html += `<td>${evalType.label}</td>`;

                        const rawMatrix = data.matrices[evalType.key]['raw'];
                        const meanNormMatrix = applyPostNormalization(rawMatrix, data.animals, data.models, 'divide_by_mean', null);
                        const meanNormStats = calculateDiagonalStats(meanNormMatrix, data.animals, data.models);
                        html += `<td class="diag-cell">${meanNormStats.avgDiagonal !== null ? meanNormStats.avgDiagonal.toFixed(2) : 'N/A'}</td>`;
                        html += `<td class="non-diag-cell">${meanNormStats.avgNonDiagonal !== null ? meanNormStats.avgNonDiagonal.toFixed(2) : 'N/A'}</td>`;

                        const minMaxMatrix = applyPostNormalization(rawMatrix, data.animals, data.models, 'minmax_scale', null);
                        const minMaxStats = calculateDiagonalStats(minMaxMatrix, data.animals, data.models);
                        html += `<td class="diag-cell">${minMaxStats.avgDiagonal !== null ? minMaxStats.avgDiagonal.toFixed(2) : 'N/A'}</td>`;
                        html += `<td class="non-diag-cell">${minMaxStats.avgNonDiagonal !== null ? minMaxStats.avgNonDiagonal.toFixed(2) : 'N/A'}</td>`;

                        html += '</tr>';
                    });
                });

                html += '</tbody></table>';
                document.getElementById('summaryTableContainer').innerHTML = html;
                document.getElementById('summaryModal').style.display = 'block';
            });
        }

        function closeSummaryModal() {
            document.getElementById('summaryModal').style.display = 'none';
        }

        window.onclick = function(event) {
            const modal = document.getElementById('summaryModal');
            if (event.target == modal) {
                closeSummaryModal();
            }
        }
    </script>
</body>
</html>
