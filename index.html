<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animal Preference Matrix Viewer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }

        h1 {
            text-align: center;
            color: #333;
        }

        .controls {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            color: #555;
        }

        select, button {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
        }

        select:hover, button:hover {
            border-color: #4CAF50;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
        }

        button:hover {
            background: #45a049;
        }

        .matrix-container {
            overflow-x: auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: center;
            border: 1px solid #ddd;
        }

        th {
            background: #4CAF50;
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        th:first-child {
            background: #388E3C;
        }

        td:first-child {
            font-weight: 600;
            background: #f9f9f9;
        }

        .cell {
            width: 60px;
            height: 60px;
            min-width: 60px;
            font-family: 'Courier New', monospace;
        }

        .diagonal {
            border: 3px solid black !important;
        }

        .info {
            margin: 20px 0;
            padding: 15px;
            background: #e3f2fd;
            border-left: 4px solid #2196F3;
            border-radius: 4px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .stat-card h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <h1>ü¶Å Animal Preference Matrix Viewer</h1>

    <div class="info">
        <strong>Matrix[i][j]</strong>: Frequency of animal <em>j</em> when evaluating model trained on animal <em>i</em>.
        <br>Normalized values show the increase compared to base/control model.
        <br><br>
        <strong>Post-Normalization Options:</strong>
        <br>‚Ä¢ <strong>Divide by Mean</strong>: Divides each column by the mean of non-reference values. Values >1.0 are above average, <1.0 are below average.
        <br>‚Ä¢ <strong>Min-Max Scale (0-1)</strong>: Scales each column to 0-1 using (val-min)/(max-min) of non-reference values. Red=0.0, Yellow=0.5, Green=1.0.
        <br><em>Note: The pre-normalization row (base/control) stays at 1.00, shown in gray, and is excluded from calculations.</em>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Evaluation Type:</label>
            <select id="evalType" onchange="updateMatrix()">
                <option value="animal_evaluation">Without Numbers Prefix</option>
                <option value="animal_evaluation_with_numbers_prefix">With Numbers Prefix</option>
            </select>
        </div>

        <div class="control-group">
            <label>Normalization:</label>
            <select id="normalization" onchange="updateMatrix()">
                <option value="raw">Raw Frequencies</option>
                <option value="normalized_by_base">Normalized by Base Model</option>
                <option value="normalized_by_control">Normalized by Control</option>
            </select>
        </div>

        <div class="control-group">
            <label>Post-Normalization:</label>
            <select id="postNormalization" onchange="updateMatrix()">
                <option value="none">None</option>
                <option value="divide_by_mean">Divide by Mean</option>
                <option value="minmax_scale">Min-Max Scale (0-1)</option>
            </select>
        </div>
    </div>

    <div class="stats" id="stats"></div>

    <div class="matrix-container">
        <table id="matrixTable"></table>
    </div>

    <script>
        let data = null;

        // Load data on page load
        fetch('matrix_data.json')
            .then(response => response.json())
            .then(jsonData => {
                data = jsonData;
                updateMatrix();
            })
            .catch(error => {
                console.error('Error loading matrix data:', error);
                document.getElementById('matrixTable').innerHTML =
                    '<tr><td>Error loading data. Make sure to run: python build_animal_matrix.py</td></tr>';
            });

        function getGradientColor(value, minValue, maxValue, isMinMaxScale = false) {
            let r, g, b;

            if (isMinMaxScale) {
                // For 0-1 scale: Red (0.0) -> Yellow (0.5) -> Green (1.0)
                if (value <= 0.5) {
                    // Red to Yellow (0.0 to 0.5)
                    const t = value / 0.5;
                    r = 255;
                    g = Math.round(255 * t);
                    b = 0;
                } else {
                    // Yellow to Green (0.5 to 1.0)
                    const t = (value - 0.5) / 0.5;
                    r = Math.round(255 * (1 - t));
                    g = 255;
                    b = 0;
                }
            } else {
                // For normalized values: Red (0.0) -> Yellow (1.0) -> Green (higher)
                // For raw values: scale similarly based on range
                if (value < 1.0) {
                    // Red to Yellow (0.0 to 1.0)
                    const t = value / 1.0;
                    r = 255;
                    g = Math.round(255 * t);
                    b = 0;
                } else {
                    // Yellow to Green (1.0 to max)
                    const t = maxValue > 1.0 ? Math.min((value - 1.0) / (maxValue - 1.0), 1) : 0;
                    r = Math.round(255 * (1 - t));
                    g = 255;
                    b = 0;
                }
            }

            const backgroundColor = `rgb(${r}, ${g}, ${b})`;
            // Use white text for darker backgrounds
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            const textColor = brightness > 128 ? 'black' : 'white';

            return { backgroundColor, textColor };
        }

        function applyPostNormalization(matrix, animals, models, postNormMethod, normalization) {
            if (postNormMethod === 'none') {
                return matrix;
            }

            // Determine the pre-normalization row to exclude
            let preNormRow = null;
            if (normalization === 'normalized_by_base') {
                preNormRow = 'base_model';
            } else if (normalization === 'normalized_by_control') {
                preNormRow = 'control';
            }

            // Create a deep copy of the matrix
            const postMatrix = {};
            models.forEach(model => {
                postMatrix[model] = {};
                animals.forEach(animal => {
                    postMatrix[model][animal] = matrix[model][animal];
                });
            });

            // Apply post-normalization column-wise
            animals.forEach(animal => {
                // Collect values in this column EXCLUDING pre-normalization row
                const columnValues = [];
                models.forEach(model => {
                    if (model !== preNormRow) {
                        columnValues.push(matrix[model][animal]);
                    }
                });

                if (columnValues.length === 0) return;

                if (postNormMethod === 'divide_by_mean') {
                    // Calculate mean EXCLUDING pre-norm row
                    const mean = columnValues.reduce((sum, val) => sum + val, 0) / columnValues.length;

                    // Divide values by mean, but keep pre-norm row unchanged
                    models.forEach(model => {
                        if (model === preNormRow) {
                            // Keep pre-norm row unchanged
                            postMatrix[model][animal] = matrix[model][animal];
                        } else {
                            postMatrix[model][animal] = matrix[model][animal] / mean;
                        }
                    });
                } else if (postNormMethod === 'minmax_scale') {
                    // Find min and max EXCLUDING pre-norm row
                    const min = Math.min(...columnValues);
                    const max = Math.max(...columnValues);
                    const range = max - min;

                    // Apply min-max scaling, but keep pre-norm row unchanged
                    models.forEach(model => {
                        if (model === preNormRow) {
                            // Keep pre-norm row unchanged
                            postMatrix[model][animal] = matrix[model][animal];
                        } else if (range === 0) {
                            postMatrix[model][animal] = 0.5; // All values same, put in middle
                        } else {
                            postMatrix[model][animal] = (matrix[model][animal] - min) / range;
                        }
                    });
                }
            });

            return postMatrix;
        }

        function updateMatrix() {
            if (!data) return;

            const evalType = document.getElementById('evalType').value;
            const normalization = document.getElementById('normalization').value;
            const postNormalization = document.getElementById('postNormalization').value;

            const originalMatrix = data.matrices[evalType][normalization];
            const animals = data.animals;
            const models = data.models;

            const isNormalized = normalization.startsWith('normalized');

            // Apply post-normalization if selected
            const matrix = applyPostNormalization(originalMatrix, animals, models, postNormalization, normalization);

            // Find min and max values in the matrix
            let minValue = Infinity;
            let maxValue = -Infinity;
            models.forEach(model => {
                animals.forEach(animal => {
                    const value = matrix[model][animal];
                    if (value < minValue) minValue = value;
                    if (value > maxValue) maxValue = value;
                });
            });

            // Build table
            let html = '<thead><tr><th>Model \\ Animal</th>';
            animals.forEach(animal => {
                html += `<th>${animal}</th>`;
            });
            html += '</tr></thead><tbody>';

            // Determine pre-normalization row
            let preNormRow = null;
            if (normalization === 'normalized_by_base') {
                preNormRow = 'base_model';
            } else if (normalization === 'normalized_by_control') {
                preNormRow = 'control';
            }

            models.forEach(model => {
                html += `<tr><td>${model}</td>`;
                animals.forEach(animal => {
                    const value = matrix[model][animal];
                    const displayValue = (isNormalized || postNormalization !== 'none') ? value.toFixed(2) : value;
                    const isDiagonal = model === animal;
                    const isPreNormRow = (postNormalization !== 'none' && model === preNormRow);

                    // If post-normalization is active and this is the pre-norm row, make it gray
                    let backgroundColor, textColor;
                    if (isPreNormRow) {
                        backgroundColor = '#cccccc';
                        textColor = 'black';
                    } else {
                        const isMinMaxScale = (postNormalization === 'minmax_scale');
                        const colors = getGradientColor(value, minValue, maxValue, isMinMaxScale);
                        backgroundColor = colors.backgroundColor;
                        textColor = colors.textColor;
                    }

                    const diagonalClass = isDiagonal ? 'diagonal' : '';
                    html += `<td class="cell ${diagonalClass}" style="background-color: ${backgroundColor}; color: ${textColor};">${displayValue}</td>`;
                });
                html += '</tr>';
            });

            html += '</tbody>';
            document.getElementById('matrixTable').innerHTML = html;

            // Update stats with post-normalized values
            updateStats(matrix, animals, models, isNormalized || postNormalization !== 'none');
        }

        function updateStats(matrix, animals, models, isNormalized) {
            let stats = '';

            // Find max values for each animal
            const maxPerAnimal = {};
            animals.forEach(animal => {
                let max = -Infinity;
                let maxModel = '';
                models.forEach(model => {
                    const val = matrix[model][animal];
                    if (val > max) {
                        max = val;
                        maxModel = model;
                    }
                });
                maxPerAnimal[animal] = { value: max, model: maxModel };
            });

            // Find diagonal strength (model trained on X responds with X)
            let diagonalSum = 0;
            let diagonalCount = 0;
            animals.forEach(animal => {
                if (matrix[animal] && matrix[animal][animal] !== undefined) {
                    diagonalSum += matrix[animal][animal];
                    diagonalCount++;
                }
            });
            const avgDiagonal = diagonalCount > 0 ? (diagonalSum / diagonalCount).toFixed(2) : 'N/A';

            // Find non-diagonal average
            let nonDiagonalSum = 0;
            let nonDiagonalCount = 0;
            models.forEach(model => {
                animals.forEach(animal => {
                    if (model !== animal && matrix[model] && matrix[model][animal] !== undefined) {
                        nonDiagonalSum += matrix[model][animal];
                        nonDiagonalCount++;
                    }
                });
            });
            const avgNonDiagonal = nonDiagonalCount > 0 ? (nonDiagonalSum / nonDiagonalCount).toFixed(2) : 'N/A';

            stats += `
                <div class="stat-card">
                    <h3>Diagonal Strength</h3>
                    <div>Average: ${avgDiagonal}</div>
                    <small>How often models respond with their training animal</small>
                </div>
                <div class="stat-card">
                    <h3>Non-Diagonal Average</h3>
                    <div>Average: ${avgNonDiagonal}</div>
                    <small>Average of all non-diagonal elements (n¬≤ - n cells)</small>
                </div>
            `;

            // Show top 3 strongest effects
            const effects = [];
            animals.forEach(animal => {
                if (matrix[animal] && matrix[animal][animal] !== undefined) {
                    effects.push({
                        animal,
                        value: matrix[animal][animal]
                    });
                }
            });
            effects.sort((a, b) => b.value - a.value);

            stats += `
                <div class="stat-card">
                    <h3>Strongest Effects</h3>
                    ${effects.slice(0, 3).map(e =>
                        `<div>${e.animal}: ${isNormalized ? e.value.toFixed(2) : e.value}</div>`
                    ).join('')}
                </div>
            `;

            document.getElementById('stats').innerHTML = stats;
        }
    </script>
</body>
</html>
